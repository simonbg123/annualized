using System;
using System.Globalization;
using System.IO;
//using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;


// todo : convert javadoc to appropriate format
// todo: make sure calculations can't be made if price properties
// not initialized
/**
 * Author: Simon Brillant-Giroux
 * <p>
 * The {@code Annualize} class is used in order to obtain
 * annualized rates of returns on investment, based on information 
 * contained in a a transaction history.
 * <p>
 * The methods {@link #printDefault} and {@link #printCustom}
 * are used to print out annualized rates of returns for any specified 
 * number of time periods in a practical, 
 * concise format,
 * whereas the {@link #calculateAnnualized} method can be used to return
 * a specific {@code double} value representing the annualized rate of return 
 * for a specific time period.
 * <p>
 * The information must be contained within a CSV file:
 * <blockquote><pre>
 *
*   <b>Year, Month, Day, transaction code, amount, number of shares, price</b>
*   <i>Transaction code is either a "p" for purchase,
*    a "s" for sale or a "r" for re-invested income.
*    Again, no number has commas or dollar sign.</i>
 * </pre></blockquote>
 * For example:
 * <blockquote><pre>
 * 		2018	8	17	s	1600.00	137.1554	11.67
 *		2018	7	3	p	1000.00	85.9749	11.63
 *		2018	6	27	r	5.77	0.4926	11.71
 *		2018	6	4	p	1000.00	86.0363	11.62
 *		2018	3	27	r	1.68	0.1466	11.46
 *		2018	1	29	p	1000.00	85.9358	11.64
 *		2018	1	3	p	500.00	43.0845	11.61
 *		2017	12	28	r	32.73	2.8248	11.59
 *		2017	12	4	p	1000.00	85.6949	11.67
 *		2017	11	20	p	500.00	42.9723	11.64
 *		2017	10	3	p	500.00	43.9808	11.37
 *		2017	7	6	p	1000.00	88.1337	11.35
 * </pre></blockquote>
 * <p>
 *
 * FTe {@code #CsvUpdater} class is used to convert
 * a text file or string containingtransaction histories into
 * a properly formatted CSV file for the purpose of using this class.
 * Currently, the {@code CsvUpdater.BMO()} method can be used to process
 * histories coming from the BMO website.
 */

namespace AnnualizeAPI
{

	public class Annualizer
	{
		readonly string newLine = Environment.NewLine;
		//private static readonly string format = "0.00";

		private int daysCounted;
		private double annualizedROR;
		private StringBuilder bufferedOutput = new StringBuilder();
		public string FundName { get; set; }
		public double PresentNumberOfShares { get; set; }
		public double PresentPrice { get; set; }
		public DateTime StartDate { get; set; }
		public DateTime FinalDate { get; set; }


		public void ResetFundFields()
		{
			FundName = null;
			daysCounted = 0;
			/*StartDate = null;
			FinalDate = null;*/
			annualizedROR = 0;
			bufferedOutput = new StringBuilder();
			PresentNumberOfShares = 0;
			PresentPrice = 0;
		}



		/** This method performs the calculations producing annualized rates 
		 * of return for single time period units.
		 * It is called by the {@code #printCustom(String, int...)} method for 
		 * each time period for which an annualized ROR is needed.
		 * It populates the fields of the {@code Annualize} object 
		 * (supplied as an argument) to the
		 * calling method so it can use those values.
		 * <p>
		 * The basic formula used is to perform the calculations is the following:
		 * <blockquote><pre>
		 * 		profits(losses) / capital   *   365 / number of days
		 * 	</pre></blockquote>
		 * When a change in capital occurs (sale or purchase of shares, except shares
		 * that are automatically purchased as part of a re-investment of income - more on that later)
		 * , we need to separate our calculation in two blocks: before and 
		 * after the transaction and this for as many transactions that occur. 
		 * Each block is evaluated for a specific amount of
		 * capital. Partial RORs are obtained with the following formula:
		 * <blockquote><pre>
		 * 		profits(losses) / capital
		 * 	</pre></blockquote>
		 * At the end, we add up all those partial RORs and apply our basic formula as such:
		 * <blockquote><pre>
		 * 		sum of partial RORs   *   365 / total number of days
		 * </pre></blockquote>
		 * <p>
		 * The CSV file goes in anti-chronological order, going from the 
		 * most recent transactions to the oldest ones.
		 * <p>
		 * Re-invested profits are counted as profits, not as new purchase of share.
		 * The reason is to give an idea of the wealth that is generated by a fund, in value
		 * or income, over time. This approach would not make sense to an investor 
		 * who do not re-invest the income.
		 * A discrepancy would be introduced as the returns would necessarily be reduced
		 * by the constant withdrawing of income.
		 * <p>
		 * The way the re-invested shares are counted as profit is that, 
		 * when a profit calculation is triggered
		 * by a change in capital or because a day-limit has been reached,
		 * it is performed by deducting the fund value of the beginning of a 
		 * period from the value at the end of
		 * the period. However, the number of shares that were re-invested 
		 * during the target period is subtracted from the beginning value of 
		 * the period. For example, if we started the period with
		 * 10,000 shares at a price of $10.00 and 532.675 were re-invested 
		 * during the period, when the period ends and the price is $10.08, 
		 * the profit is calculated in the following way:
		 * <blockquote><pre>
		 * 		10,532.675*10.08 - 10,000*10.00
		 * </pre></blockquote>
		 * Now, suppose that the calculation was triggered because 1000 shares 
		 * were purchased, then the total amount of shares will be adjusted for 
		 * the period following the calculation and the beginning
		 * value will 11,532.675*10.08 from the next period. Remember, 
		 * however, that these events occur in reverse
		 * in terms of the computations done in this method, because of the order 
		 * in which transactions are input in the CSV file.
		 *
		 */
		// returns true when reached end of file before having reached the period we want.
		// TODO : make sure a new stream is used for each call!!!
		private bool CalculateAnnualized(string csvInput, int limit)
		{

			daysCounted = 0;
			double numberOfShares = PresentNumberOfShares;
			double sharesTransacted = 0;
			double price = 0;
			double startValue = 0;
			double endValue = PresentNumberOfShares * PresentPrice;
			double sharesReinvested = 0;
			double partialROR = 0;
			double totalROR = 0;
			String transactionCode = "";
			try
			{
				using (StreamReader reader = new StreamReader(csvInput))
				{
					reader.ReadLine();       // first fieldnames
					reader.ReadLine();       // first fields
					reader.ReadLine();       // field names
					reader.ReadLine();       // legend
					string line;

					while ((line = reader.ReadLine()) != null && daysCounted < limit)
					{
						if (String.IsNullOrWhiteSpace(line)) continue;
						string[] fields = line.Split(new char[] { ' ', '\t' }, 
							StringSplitOptions.RemoveEmptyEntries);


						StartDate = new DateTime(
							int.Parse(fields[0]), int.Parse(fields[1]), int.Parse(fields[2]));   // fields 0, 1, 2
						daysCounted = (int)FinalDate.Subtract(StartDate).TotalDays;
						transactionCode = fields[3];                                              // field 3
																								  // field 4 is unused
						sharesTransacted = Double.Parse(fields[5]);                               // field 5
						price = Double.Parse(fields[6]);                                          // field 6

						// if the transaction was a re-investment of profits
						if (transactionCode.Equals("r"))
						{
							sharesReinvested += sharesTransacted;    
							// keeping track of re-investments in between ROR calculations (see below)
						}

						// Otherwise, the transaction was a purchase or sale.
						// Either way, this triggers a partial ROR calculation and then an adjustment
						// in number of shares for the next calculation period.
						else
						{

							// all the re-invested shares that were added in the previous lines
							// are finally deducted from the number of shares used to calculate the start value
							// in order to reflect the profits incurred during the period.
							numberOfShares -= sharesReinvested;
							startValue = numberOfShares * price;
							partialROR = (endValue - startValue) / startValue;
							totalROR += partialROR;

							// Adjusting the number of shares, whether transaction was a purchase or a sale
							Regex regex = new Regex("^(p|tf)$");
							numberOfShares += (regex.IsMatch(transactionCode)) ? (-1) * sharesTransacted : sharesTransacted;

							// Assigning the end value for the next calculation period from the
							// new number of shares
							endValue = numberOfShares * price;
							sharesReinvested = 0;
						}
					}
					// After the day-count limit has been reached,
					// if the last line was a re-investment, we still need a partialROR for 
					// those unused re-investment lines to be evaluated
					// but the most recent re-investment is not included because it belongs to the next
					// period (the preceding period, chronologically).
					if (transactionCode.Equals("r"))
					{
						numberOfShares -= (sharesReinvested - sharesTransacted);
						startValue = numberOfShares * price;
						partialROR = (endValue - startValue) / startValue;
						totalROR += partialROR;
					}

					annualizedROR = totalROR * 365 / daysCounted;
				}
			}
			catch (Exception ex)
			{
				using (StreamWriter errorLog = new StreamWriter("errorLog.txt", true))
				{
					errorLog.WriteLine(DateTime.Now + "\n" + this.FundName + "\n" + 
						ex.Message + newLine + ex.StackTrace + "\n\n");
				}
				throw ex;
			}
			
			if (daysCounted < limit) return true;    
			else return false;
		}

		/*
		* Helper method which coordinates calculations and output formatting for a series of time periods.
		*/
		private void CalculateAndFormat(string csvInput, params int[] limit)
		{
			DateTimeFormatInfo dateTimeFormat = CultureInfo.CreateSpecificCulture("en-US").DateTimeFormat;
			dateTimeFormat.ShortDatePattern = "MMM. dd, yyyy";

			for (int i = 0; i < limit.Length; i++)
			{
				// We output this information at the beginning of the report only
				if (i == 0) 
				{
					bufferedOutput.Append(newLine + FundName + newLine + newLine 
						+ "Annualized rates as of " + 
						FinalDate.ToString(dateTimeFormat.ShortDatePattern) + newLine + newLine);
				}

				// checking if the end of file has been reached
				if (CalculateAnnualized(csvInput, limit[i])) 
				{
					bufferedOutput.Append("Maximum ");
				}

					FormatOutput();
			}
		}

	/**
	 * Outputs to standard output a specified assortment of rates of return for the
	 * supplied CSV file.
	 * @param csvInput the CSV file containing the transaction histories
	 * @param limit the time limits for which a calculation is requested
	 * @throws IOException
	 */
	public void PrintCustom(string csvInput, params int[] limits)
	{
		PrintCustom(csvInput, Console.Out, limits);
			
	}

	/**
	* Outputs to standard output a specified assortment of rates of return for the
	* supplied CSV file.
	* @param csvInput the CSV file containing the transaction histories
	* @param limit the time limits for which a calculation is requested
	* @param output the PrintWriter object representing our output stream
	* @throws IOException
	*/
	public void PrintCustom(string csvInput, TextWriter output, params int[] limits)
	{
		CalculateAndFormat(csvInput, limits);
		output.WriteLine(bufferedOutput);
	}

	/**
	* Outputs to standard output a default assortment of rates of return for the
	* supplied CSV file.
	* @param csvInput the CSV file containing the transaction histories
	* @throws IOException
	*/
	public void PrintDefault(string csvInput)
	{
		PrintDefault(csvInput, Console.Out);
	}
	
	/**
	* Outputs to a specified file a default assortment of rates of return for the
	* supplied CSV file.
	* @param csvInput the CSV file containing the transaction histories
	* @param output the PrintWriter object representing our output stream
	* @throws IOException
	*/
	public void PrintDefault(string csvInput, TextWriter output)
	{
		PrintCustom(csvInput, output, 60, 180, 365, 100000);
	}

	public string getCustom(string csvInput, params int[] limits)
	{
		CalculateAndFormat(csvInput, limits);
		return bufferedOutput.ToString();
	}
	public string getDefault(string csvInput)
	{
		return getCustom(csvInput, 60, 180, 365, 100000);
	}
	/*
	 * Formats our final output string to a legible statement
	 * of annualized rates of return.
	 */
	private void FormatOutput()
	{
		DateTimeFormatInfo dateTimeFormat = CultureInfo.CreateSpecificCulture("en-US").DateTimeFormat;
		dateTimeFormat.ShortDatePattern = "MMM. dd, yyyy";

		TimeSpan period = FinalDate.Subtract(StartDate);
		double days = period.TotalDays;

		// couldn't keep Java precise durations, with years, months, days, etc.
		// without implementing myself.
		// Java Period had that.
			
		bufferedOutput.Append(daysCounted + "-day period: ");
			
			
		bufferedOutput.Append((100 * annualizedROR).ToString("0.00") + "%" + newLine);
		bufferedOutput.Append("starting " + StartDate.ToString(dateTimeFormat.ShortDatePattern)
			+ newLine
			+ newLine);
	}
	}
}



