using System;
using System.Globalization;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;


namespace AnnualizeLibrary
{
	/// <summary>
	/// <para>Author: Simon Brillant-Giroux</para>
	/// <para>The Annualizer class is used in order to obtain
	/// annualized rates of returns on investment, based on a transaction
	/// history contained in a .tsv file created with the TsvUpdater class.
	/// <para>The methods <code>PrintDefault</code> and <code>PrintCustom</code>
	/// are used to print out to a specified TextWriter or to the console, 
	/// annualized rates of returns for the default time periods or 
	/// for one or more specified number of time periods. The <code>GetDefault</code> and
	/// <code>GetCustom</code> canbe used to obtain a string representation of the same 
	/// information. The information is presented in a formatted, practical format.
	/// </para>
	/// 
	/// <para>The information contained in the .tsv fileas the following way:</para>
	/// <para>At the beginning of the file is written information about the current state of the fund
	/// at the time of the last file update. This is used to obtain annualized rates of returns based
	/// on the most recent information available. The format is the followingL</para>
	/// <para>Current_Share_Price    Current_Number_of_Shares    Current_Year    Current_Month    Current_Day
	/// </para>
	/// <para>Then, for the transaction histories, the format is the following:</para>
	/// <para>Year, Month, Day, transaction code, amount, number of shares, price</para>
	/// <para>Transaction codes are: p: purchase, s: sale, r: re-invested income, tf: transferred from other fund</para>
	/// <para>For example:</para>
	/// <para />2019	3	 18	r	2.06	0.1539	13.39
	/// <para />2019	2	 19	r	1.73	0.1309	13.22
	/// <para />2019	1	 16	r	1.33	0.1018	13.07
	/// <para />2018	12	 18	r	1.33	0.1020	13.04
	/// <para />2018	12	 17	s	1868.00	143.2175	13.04
	/// <para />2018	11	 16	r	3.83	0.2964	12.92
	/// <para />2018	10	 16	r	11.59	0.9028	12.84
	/// <para />2018	9	 17	r	8.40	0.6469	12.98
	/// <para />2018	8	 17	s	4000.00	306.3233	13.06
	/// <para />2018	8	 16	r	11.27	0.8627	13.06
	/// <para />2018	7	 16	r	3.56	0.2709	13.14
	/// <para />2018	6	 18	r	5.12	0.3902	13.12
	/// 
	/// 
	/// </summary>
	public class Annualizer
	{
		public static readonly int[] defaultPeriods = { 30, 60, 180, 365, 1000000 };
		readonly string newLine = Environment.NewLine;
		
		private int daysCounted;
		private double annualizedROR;
		private StringBuilder bufferedOutput = new StringBuilder();
		public string FundName { get; set; }
		public double PresentNumberOfShares { get; set; }
		public double PresentPrice { get; set; }
		public DateTime StartDate { get; set; }
		public DateTime FinalDate { get; set; }

		/// <summary>
		/// 
		/// </summary>
		public void ResetFundFields()
		{
			FundName = null;
			daysCounted = 0;
			/*StartDate = null;
			FinalDate = null;*/
			annualizedROR = 0;
			bufferedOutput = new StringBuilder();
			PresentNumberOfShares = 0;
			PresentPrice = 0;
		}
		

		/// <summary>
		/// This method performs the calculations producing annualized rates
		/// of return for single time period units. 
		/// It is called by the <code>PrintCustom</code> method for 
		/// each time period specified.
		/// It populates the fields of the <code>Annualizer</code> object.
		/// <para>
		/// The basic formula used is to perform the calculations is the following:
		/// </para>
		/// <para>appreciation(depreciation) / capital   *   365 / number of days</para>
		/// <para>
		/// When a change in capital occurs (sale or purchase of shares, except shares 
		/// that are automatically purchased as part of a re-investment of income - more on that later) 
		/// we need to separate our calculation in two blocks: before and 
		/// after the transaction and this for as many transactions that occur. 
		/// Each block is evaluated for a specific amount of capital.Partial RORs are obtained with the following formula:
		/// </para>
		/// <para>appreciation(depreciation) / capital</para>
		/// <para>At the end, we add up all those partial RORs and apply our basic formula as such:</para>
		/// <para>sum of partial RORs   *   365 / total number of days</para>
		/// <para>The TSV file goes in anti-chronological order, going from the 
		/// most recent transactions to the oldest ones.
		/// Re-invested profits are counted as appreciation, not as new purchases of share.
		/// The reason is to give an idea of the wealth that is generated by a fund, in value 
		/// or income, over time.This approach would not make sense to an investor 
		/// who do not re-invest the income. 
		/// A discrepancy would be introduced as the returns would necessarily be reduced 
		/// by the constant withdrawing of income.</para>
		/// <para>The way the re-invested shares are counted as profit is that, 
		/// when a profit calculation is triggered 
		/// by a change in capital or because a day-limit has been reached, 
		/// it is performed by deducting the fund value of the beginning of a 
		/// period from the value at the end of the period.However, the number of shares 
		/// that were re-invested 
		/// during the target period is subtracted from the beginning value of the period.For example, if we started the period with 
		/// 10,000 shares at a price of $10.00 and 532.675 were re-invested 
		/// during the period, when the period ends and the price is $10.08, 
		/// the profit is calculated in the following way:</para>
		/// <para>10,532.675*10.08 - 10,000*10.00</para>
		/// <para>Now, suppose that the calculation was triggered because 1000 shares 
		/// were purchased, then the total amount of shares will be adjusted for 
		/// the period following the calculation and the beginning 
		/// value will 11,532.675*10.08 from the next period.Remember, 
		/// however, that these events occur in reverse 
		/// in terms of the computations done in this method, because of the order 
		/// in which transactions are input in the TSV file.</para>
		/// </summary>
		/// <param name="tsvInput">the path to the .tsv transaction history file</param>
		/// <param name="limit">the limit for the current calculation, in days</param>
		/// <returns>true when reached end of file before having reached the target limit</returns>
		private bool CalculateAnnualized(string tsvInput, int limit)
		{

			daysCounted = 0;
			double numberOfShares = PresentNumberOfShares;
			double sharesTransacted = 0;
			double price = 0;
			double startValue = 0;
			double endValue = PresentNumberOfShares * PresentPrice;
			double sharesReinvested = 0;
			double partialROR = 0;
			double totalROR = 0;
			String transactionCode = "";
			try
			{
				using (StreamReader reader = new StreamReader(tsvInput))
				{
					reader.ReadLine();       // first fieldnames
					reader.ReadLine();       // first fields
					reader.ReadLine();       // field names
					reader.ReadLine();       // legend
					string line;

					while ((line = reader.ReadLine()) != null && daysCounted < limit)
					{
						if (String.IsNullOrWhiteSpace(line)) continue;
						string[] fields = line.Split(new char[] { ' ', '\t' }, 
							StringSplitOptions.RemoveEmptyEntries);


						StartDate = new DateTime(
							int.Parse(fields[0]), int.Parse(fields[1]), int.Parse(fields[2]));   // fields 0, 1, 2
						daysCounted = (int)FinalDate.Subtract(StartDate).TotalDays;
						transactionCode = fields[3];                                              // field 3
																								  // field 4 is unused
						sharesTransacted = Double.Parse(fields[5]);                               // field 5
						price = Double.Parse(fields[6]);                                          // field 6

						// if the transaction was a re-investment of profits
						if (transactionCode.Equals("r"))
						{
							sharesReinvested += sharesTransacted;    
							// keeping track of re-investments in between ROR calculations (see below)
						}

						// Otherwise, the transaction was a purchase or sale.
						// Either way, this triggers a partial ROR calculation and then an adjustment
						// in number of shares for the next calculation period.
						else
						{

							// all the re-invested shares that were added in the previous lines
							// are finally deducted from the number of shares used to calculate the start value
							// in order to reflect the profits incurred during the period.
							numberOfShares -= sharesReinvested;
							startValue = numberOfShares * price;
							partialROR = (endValue - startValue) / startValue;
							totalROR += partialROR;

							// Adjusting the number of shares, whether transaction was a purchase or a sale
							Regex regex = new Regex("^(p|tf)$");
							numberOfShares += (regex.IsMatch(transactionCode)) ? (-1) * sharesTransacted : sharesTransacted;

							// Assigning the end value for the next calculation period from the
							// new number of shares
							endValue = numberOfShares * price;
							sharesReinvested = 0;
						}
					}
					// After the day-count limit has been reached,
					// if the last line was a re-investment, we still need a partialROR for 
					// those unused re-investment lines to be evaluated
					// but the most recent re-investment is not included because it belongs to the next
					// period (the preceding period, chronologically).
					if (transactionCode.Equals("r"))
					{
						numberOfShares -= (sharesReinvested - sharesTransacted);
						startValue = numberOfShares * price;
						partialROR = (endValue - startValue) / startValue;
						totalROR += partialROR;
					}

					annualizedROR = totalROR * 365 / daysCounted;
				}
			}
			catch (Exception ex)
			{
				using (StreamWriter errorLog = new StreamWriter("errorLog.txt", true))
				{
					errorLog.WriteLine(DateTime.Now + "\n" + this.FundName + "\n" + 
						ex.Message + newLine + ex.StackTrace + "\n\n");
				}
				throw ex;
			}
			
			if (daysCounted < limit) return true;    
			else return false;
		}

		/// <summary>
		/// Helper method which coordinates calculations and output formatting for a series of time periods.
		/// </summary>
		/// <param name="tsvInput"></param>
		/// <param name="limit"></param>
		private void CalculateAndFormat(string tsvInput, params int[] limit)
		{
			DateTimeFormatInfo dateTimeFormat = CultureInfo.CreateSpecificCulture("en-US").DateTimeFormat;
			dateTimeFormat.ShortDatePattern = "MMM. dd, yyyy";

			for (int i = 0; i < limit.Length; i++)
			{
				// We output this information at the beginning of the report only
				if (i == 0) 
				{
					bufferedOutput.Append(newLine + FundName + newLine + newLine 
						+ "Annualized rates as of " + 
						FinalDate.ToString(dateTimeFormat.ShortDatePattern) + newLine + newLine);
				}

				// checking if the end of file has been reached
				if (CalculateAnnualized(tsvInput, limit[i])) 
				{
					bufferedOutput.Append("Maximum ");
				}

					FormatOutput();
			}
		}

	/// <summary>
	/// Outputs to standard output a specified assortment of rates of return for the supplied TSV file.
	/// </summary>
	/// <param name="tsvInput">the path to te </param>
	/// <param name="limits">the lengths of the periods in days for which a calculation is requested</param>
	public void PrintCustom(string tsvInput, params int[] limits)
	{
		PrintCustom(tsvInput, Console.Out, limits);

		}

	/// <summary>
	/// Outputs to a specified TextWriter a specified assortment of rates of return for the supplied TSV file.
	/// </summary>
	/// <param name="tsvInput"></param>
	/// <param name="output"></param>
	/// <param name="limits"></param>
		public void PrintCustom(string tsvInput, TextWriter output, params int[] limits)
	{
		CalculateAndFormat(tsvInput, limits);
		output.WriteLine(bufferedOutput);
		}


		/// <summary>
		/// Prints to standard output the rates of return for the default periods.
		/// </summary>
		/// <param name="tsvInput"> path to the supplied .tsv file</param>
		public void PrintDefault(string tsvInput)
	{
		PrintDefault(tsvInput, Console.Out);
	}
	
	/// <summary>
	/// Prints to a specified TextWriter annualized rates of return for the default periods.
	/// </summary>
	/// <param name="tsvInput"></param>
	/// <param name="output">path to the supplied .tsv file</param>
	public void PrintDefault(string tsvInput, TextWriter output)
	{
		PrintCustom(tsvInput, output, defaultPeriods);
	}

	public string getCustom(string tsvInput, params int[] limits)
	{
		CalculateAndFormat(tsvInput, limits);
		return bufferedOutput.ToString();
	}
	public string getDefault(string tsvInput)
	{
		return getCustom(tsvInput, defaultPeriods);
		}
	
	/// <summary>
	/// Formats our final output string to a legible statement 
	/// of annualized rates of return.
	/// </summary>
		private void FormatOutput()
	{
		DateTimeFormatInfo dateTimeFormat = CultureInfo.CreateSpecificCulture("en-US").DateTimeFormat;
		dateTimeFormat.ShortDatePattern = "MMM. dd, yyyy";

		TimeSpan period = FinalDate.Subtract(StartDate);
		double days = period.TotalDays;

		// couldn't keep Java precise durations, with years, months, days, etc.
		// without implementing myself.
		// Java Period had that.
			
		bufferedOutput.Append(daysCounted + "-day period: ");
			
			
		bufferedOutput.Append((100 * annualizedROR).ToString("0.00") + "%" + newLine);
		bufferedOutput.Append("starting " + StartDate.ToString(dateTimeFormat.ShortDatePattern)
			+ newLine
			+ newLine);
	}
	}
}



